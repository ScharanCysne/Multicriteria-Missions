import copy
from math import sqrt 
import pygame 

from utils     import limit, constrain, derivativeBivariate
from constants import *

class Drone():
    def __init__(self, x, y, index, mode):
        """
            Idealized class representing a drone
            :param x and y: represents inicial position 
        """
        # Variables used to move drone 
        self.location = pygame.math.Vector2(x,y) 
        self.velocity = pygame.math.Vector2(0,0) 
        self.acceleration = pygame.math.Vector2(0,0)
        self.target = SCREEN_WIDTH
        self.desired = pygame.math.Vector2()
        self.reached = False
        self.alive = True

        # Variables related to State Machine
        self.theta = 0 # variavel para o eight somada no seek_around
        self.count = 0
        self.id = index
        self.name = "Drone " + str(index)
        self.time_executing = 0  

        # State variables
        self.last_neighbors = pygame.math.Vector2(0,0)
        self.neighbors = pygame.math.Vector2(0,0)
        self.obstacles = pygame.math.Vector2(0,0)
        self.vulnerability = 0
        self.connectivity = 0

        # Execution mode - Training or Evaluation
        self.mode = mode


    def reached_goal(self):
        self.reached = THRESHOLD_TARGET < self.location[0]
        return self.reached


    def applyForce(self, force):
        self.acceleration += force/MASS 


    def execute(self, action, obstacles, agents, connectivity):
        """
            Execute action
            Suffer effects from the environment
        """
        self.time_executing += 1
        # Check connectivity
        self.acceleration += limit(self.last_neighbors, 0.1) if not connectivity else pygame.math.Vector2(0,0)
        # Updates velocity at every step and limits it to max_speed
        self.velocity += self.acceleration 
        # Check if valid action
        next_position = constrain(self.location + limit(self.velocity + action, FORWARD_SPEED), UPPER_X, UPPER_Y)
        for obs in obstacles:
            if (next_position - obs).magnitude() < AVOID_DISTANCE:
                action = pygame.math.Vector2(0,0)
        for drone in agents.values():
            if drone.id != self.id and (next_position - drone.location).magnitude() < AVOID_DISTANCE:
                action = pygame.math.Vector2(0,0)
        self.velocity += action
        # Limit velocity
        self.velocity = limit(self.velocity, FORWARD_SPEED)
        # Updates position
        self.location += self.velocity 
        # Constrains position to limits of screen 
        self.location = constrain(self.location, UPPER_X, UPPER_Y)
        self.acceleration *= 0
        # Print if drone reached destination
        #if not self.reached and self.reached_goal():
        #    print(f"{self.name} reached target")


    def arrive(self, target):
        """
            Arrive Steering Behavior
        """
        # Calculates vector desired 
        v = pygame.math.Vector2([target - self.location[0], 0])
        # get the distance to the target
        distance = v.magnitude() 
        direction = pygame.math.Vector2(1,0)
        
        # Modulates the force
        if distance < THRESHOLD_TARGET : 
            # close to target it will reduce velocty till stops
            direction *= FORWARD_SPEED*(1 + 1/THRESHOLD_TARGET*(distance-THRESHOLD_TARGET))
        else:
            direction *= FORWARD_SPEED

        # Steering force
        steer = direction - self.velocity
        # Limit the magnitude of the steering force.
        steer = limit(steer, SEEK_FORCE)
        # Apply force to the Drone
        self.applyForce(steer)


    def scan_neighbors(self, positions):
        """
         This method scans for neighbors CM and gets it's direction
         During training it receives all the positions from all drones 
         During evaluation it receives only the positions inside observable area 
        """
        # Calculate potential generated by topology while removing the current drone
        v = pygame.math.Vector2(0,0) 
        for position in positions:
            distance = (position - self.location).magnitude()
            if (self.mode == TRAINING and 0 < distance) or (self.mode == EVALUATION and 0 < distance):# < OBSERVABLE_RADIUS):
                # Get normalized direction of neighbor 
                direction = position - self.location 
                # Proporcional to the distance. The closer the stronger needs to be
                #direction = direction / distance 
                v += direction
        # Save last non-zero neighbours position
        if self.neighbors.magnitude() > 0:
            self.last_neighbors = self.neighbors 
        # This gives the direction of the resulting potential 
        self.neighbors = v.copy() / (len(positions) - 1)
        

    def scan_obstacles(self, positions):
        """
         This method scans for obstacles CM and gets it's direction
         During training it receives all the positions from all obstacles 
         During evaluation it receives only the positions inside observable area 
        """
        # Calculate potential generated by obstacles
        mindistance = SCREEN_WIDTH
        v = pygame.math.Vector2(0,0) 
        for position in positions:
            distance = (position - self.location).magnitude()
            if (self.mode == TRAINING and 0 < distance) or (self.mode == EVALUATION and 0 < distance < OBSERVABLE_RADIUS):
                if self.location[0] < position[0] and distance < mindistance:
                    mindistance = distance
                    # Get normalized direction of neighbor 
                    direction = position - self.location 
                    # Proporcional to the distance. The closer the stronger needs to be
                    #direction = direction / sqrt(distance) 
                    v = direction
        # This gives the direction of the resulting potential 
        self.obstacles = v.copy()


    def calculate_potential_field(self, pos_drones, pos_obstacles):
        """
            Determine resulting potential field given obstacles and other drones
        """
        alpha = beta = 0.005
        # --- Repulsion drones
        for position in pos_drones:
            distance = (self.location - position).magnitude()
            if 0 < distance < OBSERVABLE_RADIUS:
                # Proporcional to the distance. The closer the stronger needs to be
                f_repulsion = (position - self.location).normalize() / distance 
                #f_repulsion = derivativeBivariate(alpha, beta, position, self.location) / SAMPLE_TIME
                #f_repulsion = limit(f_repulsion, SEEK_FORCE)
                self.applyForce(-f_repulsion)

        # --- Repulsion obstacles 
        for position in pos_obstacles:
            distance = (self.location - position).magnitude()
            if 0 < distance < OBSERVABLE_RADIUS:
                # Proporcional to the distance. The closer the stronger needs to be
                f_repulsion = 2*(position - self.location).normalize() / sqrt(distance)
                #f_repulsion = derivativeBivariate(alpha, beta, position, self.location) / SAMPLE_TIME
                #f_repulsion = limit(f_repulsion, SEEK_FORCE)
                self.applyForce(-f_repulsion)

        # --- Repulsion walls
        # Distance to Bottom
        distance = UPPER_Y - self.location[1] 
        # Proporcional to the distance. The closer the stronger needs to be
        if distance > 0:
            f_repulsion = pygame.math.Vector2(0,2) / sqrt(distance)
        else:
            f_repulsion = pygame.math.Vector2(0,2) * SEEK_FORCE
        self.applyForce(-f_repulsion)
        
        # Distance to Top
        distance = self.location[1] - LOWER_Y 
        # Proporcional to the distance. The closer the stronger needs to be
        if distance > 0:
            f_repulsion = pygame.math.Vector2(0,-2) / sqrt(distance)
        else:
            f_repulsion = pygame.math.Vector2(0,-2) * SEEK_FORCE
        self.applyForce(-f_repulsion)


    def get_state(self):
        return [
            self.location[0] / UPPER_X,
            self.location[1] / UPPER_Y,
            self.vulnerability,
            self.connectivity,
            self.obstacles[0],
            self.obstacles[1],
            self.last_neighbors[0],
            self.last_neighbors[1]
        ]
            

    def draw(self, window):
        """
            Defines shape of Drone and draw it to screen
        """
        # usar sprite para desenhar drone
        pygame.draw.circle(window, BLUE, RATIO * self.location, radius=SIZE_DRONE, width=20)
        pygame.draw.circle(window, BLACK, RATIO * self.location, radius=RATIO * AVOID_DISTANCE, width=1)